\chapter{Экспериментальное исследование}
\section{Реализация алгоритма}
Алгоритм был реализован на языке программирования Java с использованием фреймворка Fork/Join, который хорошо подходит для параллельного исполнения рекурсивных задач.

Все операции перестановок и модификаций осуществляются на массивах индексов, чтобы избежать лишних копирований памяти.
Для нахождения медианного значения заданного критерия по всем точкам используется алгоритм <<Median of medians>> с линейным временем работы.
Операции $split$, $merge$ и поиск медианы изменяют порядок входного массива индексов, поэтому они выполняются на буферах, локальных для каждого потока.
Для поддержания упорядоченных множеств <<ступеней>> Парето-фронтов, описанных в алгоритме Фортена, в $SweepA$ и $SweepB$ используется дерево Фенвика.
По мере выполнения лексикографической сортировки заполняется вспомогательный массив $eqComp$ со следующим свойством: если точка $S_i$ совпадает по каждой координате с точкой $S_j$, то $eqComp[i] = eqComp[j]$, если $S_i$ лексикографически меньше $S_j$, то $eqComp[i] < eqComp[j]$.
Эта структура позволяет в дальнейшем избавиться от лишних сравнений.

$NDHelperB(L, H, k)$ рекурсивно делится на подзадачи в том случае, если $|L|\geq 64$ и $|H|\geq 64$. В противном случае запускается однопоточная версия процедуры.  

\section{Экспериментальное исследование алгоритма}
Ниже будут представлены результаты экспериментального исследования параллельного алгоритма.

В качестве входных данных использовались синтетически сгенерированные массивы случайных величин.
Каждая версия алгоритма запускалась $50$ раз на одной конфигурации размерности и количества точек.
В таблицах указаны минимальное, максимальное и среднее время работы в миллисекундах оригинального алгоритма и параллельной версии на $4$ потоках.
На графиках изображено среднее время исполнения оригинальной версии и параллельной версии на $2$ и $4$ потоках соответственно.

По результатам тестирования можно заключить, что параллельный алгоритм дает заметный прирост в производительности с увеличением $N$ и $M$.
Начиная с $5\cdot 10^4$ точек время работы алгоритма на четырех ядрах сокращается примерно вдвое в сравнении с оригинальной версией.
Тем не менее, на малых размерах входных данных линейный алгоритм показывает более хорошие результаты.
Это связано с накладными расходами, связанными с созданием новых объектов, выделением памяти и копированием контекста.

Тестирование проводилось на компьютере с процессором <<Intel Core i5-3317U>> и 4 гигабайтами оперативной памяти.

\input{chapters/experiments.tex}
