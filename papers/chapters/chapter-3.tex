\chapter{Реализация и экспериментальное исследование}
\section{Реализация алгоритма}
Алгоритм был реализован на языке программирования Java с использованием фреймворка Fork/Join, который хорошо подходит для параллельного исполнения рекурсивных задач.

\subsection{Используемые алгоритмы и структуры данных}
Входной двумерный массив точек остается неизменным, все операции перестановок и модификаций осуществляются на массивах индексов, чтобы избежать лишних копирований памяти.

Для нахождения медианного значения заданного критерия по всем входным точкам используется алгоритм <<Median of medians>> с линейным временем работы.

Большинство процедур в алгоритме изменяют порядок элементов во входном массиве индексов, в связи с чем в параллельной версии возникает задача изолирования памяти.

При каждом вызове \textsc{NDHelperB} копируется нужный отрезок входного массива индексов.
Для восстановления лексикографического порядка во входном массиве используется операция \textsc{merge}.
Операции \textsc{split}, \textsc{merge} и поиск медианы требуют $O(N)$ дополнительной памяти, поэтому они выполняются на буферах, локальных для каждого потока.

Для поддержания упорядоченных множеств <<ступеней>> Парето-фронтов в \textsc{SweepA} и \textsc{SweepB}, описанных в алгоритме Фортена, были реализованы красно-черное дерево и дерево Фенвика.

Начальная лексикографическая сортировка точек осуществляется с помощью сортировки слиянием.
По мере выполнения лексикографической сортировки заполняется вспомогательный массив $eqComp$ со следующим свойством: если точка $S_i$ совпадает в каждой координате с точкой $S_j$, то $eqComp[i] = eqComp[j]$, если $S_i$ лексикографически меньше $S_j$, то $eqComp[i] < eqComp[j]$.
Эта структура позволяет в дальнейшем сравнивать точки за $O(1)$.

\subsubsection{\textsc{NDHelperA}}
Для реализации описанной во второй главе модификации процедуры \textsc{NDHelperA} необходимо ввести дополнительную структуру, представляющую контекст для отложенного исполнения \textsc{NDHelperB}.

\begin{lstlisting}[float=!h,caption={Вспомогательная структура <<контекст>> для \textsc{NDHelperA}}]
class Context {
    int k;
    int[] compareWith;
    List<Future> futures;
    ...
}
\end{lstlisting}

Добавим в \textsc{NDHelperA} дополнительный аргумент --- список контекстов для отложенного исполнения \textsc{NDHelperB}.

В каждом таком контексте будет храниться:
\begin{itemize}
    \item размерность $k$, по которой будет производиться сравнение;
    \item список индексов $compareWith$ --- точки, с которыми необходимо сравниться;
    \item список $futures$, в который необходимо положить результат отложенного вычисления \textsc{NDHelperB};
\end{itemize}

Если входящий список контекстов не пуст, то до завершения работы \textsc{NDHelperA} необходимо асинхронно запустить выполнение \textsc{NDHelperB} на каждой из частей $L$, $M$ и $H$ в паре с точками из каждого контекста, или на входном отрезке целиком, если деление на части не выполняется.

Результат отложенного исполнения необходимо положить в список $futures$, чтобы у нас была возможность дождаться завершения работы в необходимой нам точке.

В \textsc{NDHelperA(L)} складывается два новых контекста: первый с отрезком $M$ и списком $waitM$, второй --- с отрезком $H$ и списком $waitH$.
В \textsc{NDHelperA(M)} добавляется контекст с $H$ и списком $waitH$.
Перед запуском \textsc{NDHelperA(M)} мы должны дождаться выполнения задач в $waitM$, а перед запуском \textsc{NDHelperA(H)} --- задач в $waitH$.
Таким образом, все требуемые сравнения точек будут завершены к нужному моменту.

\subsection{Переключение на последовательную версию}
Каждый параллельный вызов \textsc{NDHelperB} при использовании $Fork/Join$ влечет за собой накладные расходы, потому что нам нужно создать новый объект для каждой подзадачи, а также скопировать необходимые отрезки индексов.
Поэтому при достаточно маленьких размерах входных массивов имеет смысл запускать однопоточную версию процедуры.

Был проведен ряд экспериментов при $N=\{10^4, 5\cdot10^4, 10^5\}$, $M=\{3,4,\ldots,15\}$.
В качестве порога в \textsc{NDHelperB} рассматривались степени двойки от $4$ до $1024$.

Лучшие результаты были достигнуты при пороге равном $32$.
Таким образом, если $|L| < 32$ или $|H| < 32$, то запускается однопоточная версия \textsc{NDHelperB(L, H, k)}.

\section{Экспериментальное исследование алгоритма}
Далее будут представлены результаты экспериментального исследования эффективности предложенного алгоритма.

\input{chapters/experiments.tex}
