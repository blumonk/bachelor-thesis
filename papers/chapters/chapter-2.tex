\chapter{Реализация алгоритма}
\section{Предлагаемая схема параллелизации}
Две основные процедуры в алгоритме Фортена с модификацией Буздалова --- $NDHelperA$ и $NDHelperB$.
Процедура $NDHelperA$ делит задачу на подзадачи и сливает результаты воедино посредством $NDHelperB$.
Процедура $NDHelperB$ сама по себе является рекурсивной, следующей парадигме <<разделяй и властвуй>>.
Деление задач происходит до момента, когда размерность $k$ станет равна $2$, что в дальнейшем обрабатывается процедурами $SweepA$ и $SweepB$ соответственно.

Можно заметить, что на момент вызова процедуры $NDHelperB(L, H, k)$ ранги точек из множества $L$ уже вычислены и в дальнейшем остаются неизменными.
Также заметим, что порядок вызова подзадач в теле $NDHelperB$ не нарушит корректности алгоритма.
Более того, мы можем разделить множество $L$ на любое количество частей ${L_1, L_2,\ldots, L_n}$ и тогда результат исполнения $NDHelperB(L_i, H, k)$ для всех $i$ будет идентичен результату исполнения $NDHelperB(L, H, k)$.
Таким образом, $NDHelperB$ допускает возможность параллельного исполнения.

С параллелизацией процедуры $NDHelperA$ возникают сложности.
Внутренние вызовы $NDHelperA$ и $NDHelperB$ зависят друг от друга и имеют строго определенную последовательность. 

\section{Детали реализации}
Алгоритм был реализован на языке программирования Java с использованием фреймворка Fork/Join, который хорошо подходит для распараллеливания рекурсивных задач.

Все операции перестановок и модификаций осуществляются на массивах индексов, чтобы избежать лишних копирований памяти.
Для нахождения медианного значения заданного критерия по всем точкам используется алгоритм <<Median of medians>> с линейным временем работы.
Операции $split$, $merge$ и поиск медианы изменяют порядок входного массива индексов, поэтому они выполняются на буферах, локальных для каждого потока.
Для поддержания упорядоченных множеств <<ступеней>> Парето-фронтов, описанных в алгоритме Фортена, в $SweepA$ и $SweepB$ используется дерево Фенвика.
По мере выполнения лексикографической сортировки заполняется вспомогательный массив $eqComp$ со следующим свойством: если точка $S_i$ совпадает по каждой координате с точкой $S_j$, то $eqComp[i] = eqComp[j]$, если $S_i$ лексикографически меньше $S_j$, то $eqComp[i] < eqComp[j]$.
Эта структура позволяет в дальнейшем избавиться от лишних сравнений.

$NDHelperB(L, H, k)$ рекурсивно делится на подзадачи в том случае, если $|L|\geq 64$ и $|H|\geq 64$. В противном случае запускается однопоточная версия процедуры.  

\section{Экспериментальное исследование алгоритма}
Ниже будут представлены результаты экспериментального исследования параллельного алгоритма.

В качестве входных данных использовались синтетически сгенерированные массивы случайных величин.
Каждая версия алгоритма запускалась $50$ раз на одной конфигурации размерности и количества точек.
В таблицах указаны минимальное, максимальное и среднее время работы в миллисекундах оригинального алгоритма и параллельной версии на $4$ потоках.
На графиках изображено среднее время исполнения оригинальной версии и параллельной версии на $2$ и $4$ потоках соответственно.

По результатам тестирования можно заключить, что параллельный алгоритм дает заметный прирост в производительности с увеличением $N$ и $M$.
Начиная с $5\cdot 10^4$ точек время работы алгоритма на четырех ядрах сокращается примерно вдвое в сравнении с оригинальной версией.
Тем не менее, на малых размерах входных данных линейный алгоритм показывает более хорошие результаты.
Это связано с накладными расходами, связанными с созданием новых объектов, выделением памяти и копированием контекста.

Тестирование проводилось на компьютере с процессором <<Intel Core i5-3317U>> и 4 гигабайтами оперативной памяти.

\input{chapters/experiments.tex}
