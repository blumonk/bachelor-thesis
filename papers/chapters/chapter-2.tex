\chapter{Описание алгоритма}
\section{Предлагаемая схема параллелизации}
Рассмотрим две основные процедуры в алгоритме Фортена с модификацией Буздалова --- $NDHelperA$ и $NDHelperB$.
Обе процедуры являются рекурсивными и следуют принципу <<разделяй и властвуй>>.
Входящие множества точек разделяются на три части $L$, $M$, $H$ относительно медианного значения по $k$-й координате.
Далее $NDHelperA$ и $NDHelperB$, используя тот факт, что точки из подмножества $H$ не могут доминировать точки из $M$, а точки из $M$ не могут доминировать точки из $L$, рекурсивно запускают подзадачи с уменьшением размерности $k$.
Деление задач происходит до того момента, когда размерность $k$ станет равна $2$, что в дальнейшем обрабатывается процедурами $SweepA$ и $SweepB$ соответственно.

\subsection{NDHelperB}
Можно заметить, что на момент вызова процедуры $NDHelperB(L, H, k)$ ранги точек из множества $L$ уже вычислены и в дальнейшем остаются неизменными.
Также заметим, что для корректной работы процедуры, каждая точка из множества $H$ должна быть сравнена с каждой точкой из множество $L$, но при этом порядок сравнений не влияет на результат.

Таким образом мы можем заключить, что рекурсивные вызовы подзадач в теле $NDHelperB$ являются независимыми и порядок их исполнения не влияет на корректность алгоритма.
Более того, мы можем разделить множество $L$ на любое количество частей ${L_1, L_2,\ldots, L_n}$ и тогда результат исполнения $NDHelperB(L_i, H, k)$ для всех $1\leq i\leq n$ будет идентичен результату исполнения $NDHelperB(L, H, k)$.
Следовательно, $NDHelperB$ допускает возможность параллельного исполнения.

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{images/ndb.png}
\caption{Вызовы подзадач в $NDHelperB$}
\label{pic4}
\end{figure}

\subsection{NDHelperA}
С параллелизацией процедуры $NDHelperA$ возникают определенные сложности.
Внутренние вызовы $NDHelperA$ и $NDHelperB$ зависят друг от друга и имеют строго определенную последовательность. 
Например, перед выполнением $NDHelperA(M, k-1)$ вычисления в процедурах $NDHelperA(L, k)$ и $NDHelperB(L, M, k-1)$ уже должны быть выполнены.

Тем не менее, опираясь на утверждение из предыдущей секции, мы можем заметить, что как только ранги какого-то левого подмножества входящих точек будут вычислены, мы сразу же можем начать сравнивать эти точки с подмножествами точек, лежащими правее по $k$-й координате, при помощи процедуры $NDHelperB$.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{images/async.png}
\caption{Идея параллелизации процедуры $NDHelperA$}
\end{figure}

Пусть подмножество $L$ в вызове $NDHelperA(L, k)$ посредством $SplitBy$ поделится на три части по $k$-й координате: $L_L$, $M_L$ и $H_L$.
Заметим, что вместо $NDHelperB(L, M, k-1)$ мы можем асинхронно вызывать $NDHelperB(L_L, M, k-1)$, $NDHelperB(M_L, M, k-1)$, $NDHelperB(H_L, M, k-1)$ по мере вычисления рангов каждой из частей.

Аналогичным образом мы можем начать сравнивать точки из $L_L$, $M_L$, $H_L$ и $L_M, M_M, H_M$ с точками из $H$ как только ранги этих точек уже будут известны.
Эту идею можно развить дальше, разделив вызовы $NDHelperB$ на более мелкие подзадачи.

\section{Детали реализации}
Алгоритм был реализован на языке программирования Java с использованием фреймворка Fork/Join, который хорошо подходит для распараллеливания рекурсивных задач.

Все операции перестановок и модификаций осуществляются на массивах индексов, чтобы избежать лишних копирований памяти.
Для нахождения медианного значения заданного критерия по всем точкам используется алгоритм <<Median of medians>> с линейным временем работы.
Операции $split$, $merge$ и поиск медианы изменяют порядок входного массива индексов, поэтому они выполняются на буферах, локальных для каждого потока.
Для поддержания упорядоченных множеств <<ступеней>> Парето-фронтов, описанных в алгоритме Фортена, в $SweepA$ и $SweepB$ используется дерево Фенвика.
По мере выполнения лексикографической сортировки заполняется вспомогательный массив $eqComp$ со следующим свойством: если точка $S_i$ совпадает по каждой координате с точкой $S_j$, то $eqComp[i] = eqComp[j]$, если $S_i$ лексикографически меньше $S_j$, то $eqComp[i] < eqComp[j]$.
Эта структура позволяет в дальнейшем избавиться от лишних сравнений.

$NDHelperB(L, H, k)$ рекурсивно делится на подзадачи в том случае, если $|L|\geq 64$ и $|H|\geq 64$. В противном случае запускается однопоточная версия процедуры.  

\section{Экспериментальное исследование алгоритма}
Ниже будут представлены результаты экспериментального исследования параллельного алгоритма.

В качестве входных данных использовались синтетически сгенерированные массивы случайных величин.
Каждая версия алгоритма запускалась $50$ раз на одной конфигурации размерности и количества точек.
В таблицах указаны минимальное, максимальное и среднее время работы в миллисекундах оригинального алгоритма и параллельной версии на $4$ потоках.
На графиках изображено среднее время исполнения оригинальной версии и параллельной версии на $2$ и $4$ потоках соответственно.

По результатам тестирования можно заключить, что параллельный алгоритм дает заметный прирост в производительности с увеличением $N$ и $M$.
Начиная с $5\cdot 10^4$ точек время работы алгоритма на четырех ядрах сокращается примерно вдвое в сравнении с оригинальной версией.
Тем не менее, на малых размерах входных данных линейный алгоритм показывает более хорошие результаты.
Это связано с накладными расходами, связанными с созданием новых объектов, выделением памяти и копированием контекста.

Тестирование проводилось на компьютере с процессором <<Intel Core i5-3317U>> и 4 гигабайтами оперативной памяти.

\input{chapters/experiments.tex}
