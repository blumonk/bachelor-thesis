\chapter{Обзор предметной области}
В этой главе описываются основные понятия и термины предметной области, к которой относится представленная работа. Также проводится обзор имеющихся алгоритмических решений и формулируется постановка задачи.

\section{Основные определения}

Принципиальное отличие многокритериальных задач оптимизации от однокритериальных заключается в том, что во втором случае целью является поиск самого оптимального решения. В случае же задачи многокритериальной оптимизации такого решения может не существовать вследствие возможных конфликтов целевых функций. Таким образом, многокритериальная оптимизация основывается на компромиссном поиске группы оптимальных решений в смысле Парето.
\begin{definition}
    В $M$-мерном пространстве, точка $A = (a_1, \ldots, a_M)$ \textit{доминирует в смысле Парето} точку $B = (b_1, \ldots, b_M)$, когда для всех $1 \leq i \leq M$ выполняется неравенство $a_i \leq b_i$ и существует хотя бы одно такое $j$, что $a_j < b_j$.
\end{definition}
\begin{definition}
    Множество оптимальных по Парето недоминируемых решений называется \textit{Парето-фронтом}.
\end{definition}
\begin{definition}
    \textit{Недоминирующая сортировка} множества точек $S$ в $M$-мерном пространстве --- это процедура, в процессе которой всем точкам, которые не доминируются никакими другими точками, назначается ранг $0$. Далее всем точкам, которые доминируются только точками с рангом $0$, назначается ранг $1$, и т.д. Все точки с рангом $i$ доминируются только точками с рангом не более $i + 1$.
\end{definition}

\section{Обзор существующих алгоритмов}
\subsection{Тривиальный алгоритм}
Рассмотрим самую наивную версию алгоритма недоминирующей сортировки. Найдем все недоминируемые точки с нулевым рангом, вычеркнем эти точки и будем повторять эту процедуру, каждый раз назначая ранг на единицу больше, чем на предыдущей итерации. Тогда, если $M$ --- количество критериев отбора или размерность множества точек (решений), а $N$ --- количество решений, нам необходимо за время $O(MN^2)$ сравнить $O(N^2)$ пар точек по каждому из $M$ критериев и повторить эту процедуру в худшем случае $N$ раз. Таким образом получаем время работы $O(MN^3)$.

Кунг и др. в своей работе предложили алгоритм поиска недоминируемых решений со сложностью $O(N\log^{M-1}N)$. Совместив предложенный алгоритм с идеей удаления найденных точек, описанной в наивном алгоритме, мы получаем алгоритм недоминирующей сортировки с общей сложностью $O(N^2\log^{M-1}N)$ в худшем случае, если максимальный ранг решений --- $O(N)$.

\subsection{Быстрая недоминирующая сортировка}
Деб в своей работе предложил алгоритм <<Быстрой недоминирующей сортировки>>, улучшив асимптотическую сложность алгоритма до $O(MN^2)$. Этот алгоритм является базисным с точки зрения эффективности в семействе алгоритмов <<Разделяй и властвуй>>.

Йенсен был первым, кто предложил алгоритм недоминирующей сортировки со сложностью $O(N\log^{M-1}N)$, позволив тем самым эффективно вычислять ранги точек для типичных конфигураций входных значений. Однако его алгоритм имел существенный недостаток: он работал корректно только в предположении, что никакие два решения не имеют одинаковых значений по одному и тому же критерию. Фанг и др. в своей работе пришли к заключению, что алгоритм Йенсена неспособен генерировать такие же недоминирующие фронты точек, как оригинальный алгоритм NSGA-II. Также они продемонстрировали, что устранение главного недостатка алгоритма Йенсена является нетривиальной задачей.

Решение данной проблемы было предложено Фортеном и др. Предложенный им <<обобщенный>> алгоритм недоминирующей сортировки работает корректно на любых входных данных, сохраняя при этом среднюю временную сложность $O(N\log^{M-1}N)$. Тем не менее было доказано, что в худшем случае время работы алгоритма составляет $O(N^2M)$.

Дальнейшее улучшение недоминирующей сортировки Фортена было предложено Буздаловым и др. В своей работе он модифицирует алгоритм и доказывает оценку $O(N\log^{M-1}N)$ для худшего случая.

\section{Описание алгоритма <<Разделяй и властвуй>>}
Алгоритм Фортена состоит из нескольких процедур:
\begin{itemize}
    \item $NonDominatedSort(S, K)$ --- главная процедура, получающая на вход множество точек $S$ и размерность $K$ и возвращающая результат недоминирующей сортировки --- последовательность Парето-фронтов, содержащих точки исходного множества. Внутри процедуры осуществляется предварительная обработка данных и вызывается процедура $NDHelperA$.
    \item $NDHelperA(S, k)$ вычисляет ранги точек множества $S$, основываясь на первых $k$ критериях. Процедура может рекурсивно вызывать саму себя, а также $NDHelperB$, $SweepA$ и $SplitA$.
    \item $NDHelperB(L, H, k)$ назначает ранги точкам из множества $H$, сравнивая их с точками из множества $L$, основываясь на первых $k$ критериях. Эта процедура может рекурсивно вызывать саму себя, $SweepB$ и $SplitB$.
    \item $SweepA(S)$ --- это процедура, определяющая ранги точек по первым двум координатам, используя метод заметающей прямой. Время ее работы --- $O(|S|\log|S|)$.
    \item $SweepB(L, H)$ определяет ранги точек из множества $H$, сравнивая их с точками множества $L$ по первым двум критериям. В ней также используется метод заметающей прямой, а время ее работы оценивается как $O((|L| + |H|)\log{|L|})$.
    \item $SplitA(S, k)$ разделяет множество точек $S$ на два подмножества, сравнивая $k$-ю координату каждой точки с медианным значением. Точки, имеющие по $k$-му критерию значение, равное медиане, добавляются к меньшему из двух подмножеств.
    \item $SplitB(L, H, k)$ разделяет каждое из множеств $L$ и $H$ на два, используя аналогичную процедуру. В качестве опорного элемента используется медиана $k$-х координат большего из двух исходных множеств.
\end{itemize}
Стоит отметить, что все вышеперечисленные процедуры сохраняют лексикографический порядок исходных множеств.

Буздалов и др. предложили модифицировать процедуры $SplitA$ и $SplitB$, а также соответственно вызывающие их процедуры $NDHelperA$ и $NDHelperB$. Вместо первых двух будет использоваться метод $SplitBy(S, m, k)$, который разделяет входящее множество точек $S$ не на две, а на три части:
\begin{itemize}
    \item $L$ --- множество точек, $k$-я координата которых меньше $m$;
    \item $M$ --- множество точек, $k$-я координата которых равна $m$;
    \item $H$ --- множество точек, $k$-я координата которых больше $m$;
\end{itemize}


\begin{algorithm}[!h]
\caption{Процедура SplitBy. Разделение точек из $S$ на три подмножества по $k$-му критерию относительно значения $m$.}\label{lst0}
\begin{algorithmic}
\Procedure{SplitBy}{S, m, k}
    \State $L \gets \{s \in S|s_k < m\}$
    \State $M \gets \{s \in S|s_k = m\}$
    \State $H \gets \{s \in S|s_k > m\}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Процедура NDHelperA. Определение рангов точек из $S$ по $k$ первым критериям.}\label{lst1}
\begin{algorithmic}
\Procedure{NDHelperA}{$S, k$}
    \If{$|S| < 2$}
        \State \Return
    \ElsIf{$|S| = 2$}
        \State $\{s^{(1)}, s^{(2)}\}\gets S$
        \If{$s_{1:k}^{(1)} \prec s_{1:k}^{(2)}$}
            \State $RANK(S^{(2)})\gets \max\{RANK(S^{(2)}), RANK(S^{(1)})+1\}$ 
        \EndIf
    \ElsIf{$k = 2$}
        \State$SweepA(S)$
    \ElsIf{$|\{s_k | s \in S\}| = 1$}
        \State$NDHelperA(S, k-1)$
    \Else
        \State $L,M,H \gets SplitBy(S, median\{s_k|s \in S\}, k)$
        \State $NDHelperA(L, k)$
        \State $NDHelperB(L, M, k-1)$
        \State $NDHelperA(M, k-1)$
        \State $NDHelperB(L \cup M, H, k-1)$
        \State $NDHelperA(H, k)$
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!h]
\caption{Процедура NDHelperB. Назначение рангов точкам из $H$ относительно точек из $L$ по $k$ первым критериям.}\label{lst2}
\begin{algorithmic}
\Procedure{NDHelperB}{$L, H, k$}
    \If{$|L| = 0$ or $|H| = 0$}
        \State \Return
    \ElsIf{$|L| = 1$ or $|H| = 1$}
        \ForAll{$h \in H, l \in L$}
            \If{$l_{1:k} \preceq h_{1:k}$}
                \State $RANK(h) \gets \max\{RANK(h), RANK(l) + 1\}$
            \EndIf
        \EndFor
    \ElsIf{$k = 2$}
        \State $SweepB(L, H)$
    \ElsIf{$ max\{l_k|l \in L\} \leq min\{h_k|h \in H\}$}
        \State $NDHelperB(L, H, k-1)$
    \Else
        \State $m \gets median\{s_k|s \in L \cup H\}$
        \State $L_1, M_1, H_1 \gets SplitBy(L, m, k)$
        \State $L_2, M_2, H_2 \gets SplitBy(H, m, k)$
        \State $NDHelperB(L_1, L_2, k)$
        \State $NDHelperB(L_1, M_2, k-1)$
        \State $NDHelperB(M_1, M_2, k-1)$
        \State $NDHelperB(L_1 \cup M_1, H_2, k-1)$
        \State $NDHelperB(H_1, H_2, k)$
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
