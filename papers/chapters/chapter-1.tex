\chapter{Обзор предметной области}
В этой главе описываются основные понятия и термины предметной области, к которой относится представленная работа. Также проводится обзор имеющихся алгоритмических решений и формулируется постановка задачи.

\section{Основные определения}

Принципиальное отличие многокритериальных задач оптимизации от однокритериальных заключается в том, что во втором случае целью является поиск самого оптимального решения. В случае же задачи многокритериальной оптимизации такого решения может не существовать вследствие возможных конфликтов целевых функций. Таким образом, многокритериальная оптимизация основывается на компромиссном поиске группы оптимальных решений в смысле Парето.
\begin{definition}
    В $M$-мерном пространстве, точка $A = (a_1, \ldots, a_M)$ \textit{доминирует в смысле Парето} точку $B = (b_1, \ldots, b_M)$, когда для всех $1 \leq i \leq M$ выполняется неравенство $a_i \leq b_i$ и существует хотя бы одно такое $j$, что $a_j < b_j$.
\end{definition}
\begin{definition}
    Множество оптимальных по Парето недоминируемых решений называется \textit{Парето-фронтом}.
\end{definition}
\begin{definition}
    \textit{Недоминирующая сортировка} множества точек $S$ в $M$-мерном пространстве --- это процедура, в процессе которой всем точкам, которые не доминируются никакими другими точками, назначается ранг $0$. Далее всем точкам, которые доминируются только точками с рангом $0$, назначается ранг $1$, и т.д. Все точки с рангом $i$ доминируются только точками с рангом не более $i - 1$.
\end{definition}

\section{Обзор существующих алгоритмов}
\subsection{Тривиальный алгоритм}
Рассмотрим самую наивную версию алгоритма недоминирующей сортировки. Найдем все недоминируемые точки с нулевым рангом, вычеркнем эти точки и будем повторять эту процедуру, каждый раз назначая ранг на единицу больше, чем на предыдущей итерации. Тогда, если $M$ --- количество критериев отбора или размерность множества точек (решений), а $N$ --- количество решений, нам необходимо за время $O(MN^2)$ сравнить $O(N^2)$ пар точек по каждому из $M$ критериев и повторить эту процедуру в худшем случае $N$ раз. Таким образом получаем время работы $O(MN^3)$.

Кунг и др. в своей работе предложили алгоритм поиска недоминируемых решений со сложностью $O(N\log^{M-1}N)$. Совместив предложенный алгоритм с идеей удаления найденных точек, описанной в наивном алгоритме, мы получаем алгоритм недоминирующей сортировки с общей сложностью $O(N^2\log^{M-1}N)$ в худшем случае, если максимальный ранг решений --- $O(N)$.

\subsection{Быстрая недоминирующая сортировка}
Деб в своей работе предложил алгоритм <<Быстрой недоминирующей сортировки>>, улучшив асимптотическую сложность алгоритма до $O(MN^2)$. Этот алгоритм является базисным с точки зрения эффективности в семействе алгоритмов <<Разделяй и властвуй>>.

Йенсен был первым, кто предложил алгоритм недоминирующей сортировки со сложностью $O(N\log^{M-1}N)$, позволив тем самым эффективно вычислять ранги точек для типичных конфигураций входных значений. Однако его алгоритм имел существенный недостаток: он работал корректно только в предположении, что никакие два решения не имеют одинаковых значений по одному и тому же критерию. Фанг и др. в своей работе пришли к заключению, что алгоритм Йенсена неспособен генерировать такие же недоминирующие фронты точек, как оригинальный алгоритм NSGA-II. Также они продемонстрировали, что устранение главного недостатка алгоритма Йенсена является нетривиальной задачей.

Решение данной проблемы было предложено Фортеном и др. Предложенный им <<обобщенный>> алгоритм недоминирующей сортировки работает корректно на любых входных данных, сохраняя при этом среднюю временную сложность $O(N\log^{M-1}N)$. Тем не менее было доказано, что в худшем случае время работы алгоритма составляет $O(N^2M)$.

Дальнейшее улучшение недоминирующей сортировки Фортена было предложено Буздаловым и др. В своей работе он модифицирует алгоритм и доказывает оценку $O(N\log^{M-1}N)$ для худшего случая. Более подробное описание алгоритма с модификацией будет представлено ниже.

\subsection{Алгоритм Роя}
Существует также алгоритм <<Best Order Sort>>, предложенный Роем и др. с вычислительной сложностью $O(MN\log{M}+MN^2)$. В худшем случае время его работы --- $O(MN^2)$, но на некоторых входных данных алгоритм может работать за $O(MN\log{M})$. Авторы не предоставляют более строгого теоретического доказательства эффективности данного алгоритма. Как показывает практика, алгоритм показывает не самые лучшие результаты на больших массивах входных данных. В рамках представленной работы данный алгоритм интереса не представляет.

\section{Описание алгоритма <<Разделяй и властвуй>>}
Алгоритм Фортена состоит из нескольких процедур:
\begin{itemize}
    \item $NonDominatedSort(S, K)$ --- главная процедура, получающая на вход множество точек $S$ и размерность $K$ и возвращающая результат недоминирующей сортировки --- последовательность Парето-фронтов, содержащих точки исходного множества. Внутри процедуры осуществляется предварительная обработка данных и вызывается процедура $NDHelperA$.
    \item $NDHelperA(S, k)$ вычисляет ранги точек множества $S$, основываясь на первых $k$ критериях. Процедура может рекурсивно вызывать саму себя, а также $NDHelperB$, $SweepA$ и $SplitA$.
    \item $NDHelperB(L, H, k)$ назначает ранги точкам из множества $H$, сравнивая их с точками из множества $L$, основываясь на первых $k$ критериях. Эта процедура может рекурсивно вызывать саму себя, $SweepB$ и $SplitB$.
    \item $SweepA(S)$ --- это процедура, определяющая ранги точек по первым двум координатам, используя метод заметающей прямой. Время ее работы --- $O(|S|\log|S|)$.
    \item $SweepB(L, H)$ определяет ранги точек из множества $H$, сравнивая их с точками множества $L$ по первым двум критериям. В ней также используется метод заметающей прямой, а время ее работы оценивается как $O((|L| + |H|)\log{|L|})$.
    \item $SplitA(S, k)$ разделяет множество точек $S$ на два подмножества, сравнивая $k$-ю координату каждой точки с медианным значением. Точки, имеющие по $k$-му критерию значение, равное медиане, добавляются к меньшему из двух подмножеств.
    \item $SplitB(L, H, k)$ разделяет каждое из множеств $L$ и $H$ на два, используя аналогичную процедуру. В качестве опорного элемента используется медиана $k$-х координат большего из двух исходных множеств.
\end{itemize}
Стоит отметить, что все вышеперечисленные процедуры сохраняют лексикографический порядок исходных множеств.

Буздалов и др. предложили модифицировать процедуры $SplitA$ и $SplitB$, а также соответственно вызывающие их процедуры $NDHelperA$ и $NDHelperB$. Вместо первых двух будет использоваться метод $SplitBy(S, m, k)$, который разделяет входящее множество точек $S$ не на две, а на три части:
\begin{itemize}
    \item $L$ --- множество точек, $k$-я координата которых меньше $m$;
    \item $M$ --- множество точек, $k$-я координата которых равна $m$;
    \item $H$ --- множество точек, $k$-я координата которых больше $m$;
\end{itemize}

\input{chapters/code.tex}

\section{Постановка задачи}
Как было сказано ранее, разработка эффективных алгоритмов недоминирующей сортировки является актуальной задачей в области эволюционных алгоритмов. Алгоритм Фортена в модификации Буздалова обладает хорошей асимптотической сложностью и показывает хорошие результаты на больших объемах входных данных. Тем не менее, этот алгоритм не использует возможностей многопроцессорных систем, в связи с чем возникает задача его параллелизации.
